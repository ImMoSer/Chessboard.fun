# Аудит производительности Chessboard.fun

## 1. Общее резюме

Основной проблемой производительности приложения является **большой размер начального JavaScript-бандла**. Это приводит к длительной начальной загрузке, особенно на медленных интернет-соединениях. Предупреждение от Vite (`Some chunks are larger than 500 kB`) прямо указывает на эту проблему.

Ключевая причина — **отсутствие стратегии разделения кода (code-splitting)** для маршрутов и тяжелых зависимостей.

## 2. Критические проблемы (Требуют срочного внимания)

### 2.1. Статическая загрузка маршрутов (компонентов страниц)

**Проблема:** Большинство компонентов страниц (Views) в `src/router/index.ts` импортируются статически.

*Пример из `src/router/index.ts`:*
```typescript
import WelcomeView from '../views/WelcomeView.vue'
import AboutView from '../views/AboutView.vue'
// ... и многие другие

const router = createRouter({
  routes: [
    {
      path: '/',
      name: 'welcome',
      component: WelcomeView, // Статический импорт
    },
    {
      path: '/about',
      name: 'about',
      component: AboutView, // Статический импорт
    },
    // ...
  ],
})
```

**Последствия:** Код для всех этих страниц объединяется в один большой файл `index.[hash].js`, который должен быть загружен и обработан браузером перед отображением даже самой первой страницы.

**Решение:** Необходимо перевести все компоненты страниц на **динамический импорт**. Это позволит загружать код для каждой страницы только в тот момент, когда пользователь на нее переходит.

*Пример исправления:*
```typescript
const router = createRouter({
  routes: [
    {
      path: '/',
      name: 'welcome',
      component: () => import('../views/WelcomeView.vue'), // Динамический импорт
    },
    {
      path: '/about',
      name: 'about',
      component: () => import('../views/AboutView.vue'), // Динамический импорт
    },
    // ... и так далее для всех маршрутов
  ],
})
```

### 2.2. Включение "тяжелых" зависимостей в основной бандл

**Проблема:** Такие библиотеки, как `echarts` и `vue-echarts`, используются для отображения статистики в `UserCabinetView.vue`. Поскольку `UserCabinetView` импортируется статически, эти крупные библиотеки попадают в основной бандл, увеличивая его размер для всех пользователей, даже для тех, кто никогда не зайдет в личный кабинет.

**Последствия:** Увеличение начального времени загрузки для всех пользователей.

**Решение:** Эта проблема будет автоматически решена после внедрения динамических импортов для маршрутов, как описано в пункте 2.1. Когда `UserCabinetView` будет загружаться динамически, все его зависимости (включая `echarts`) также будут загружаться вместе с ним в отдельном файле.

## 3. Области для дальнейшей оптимизации (некритично)

### 3.1. Оптимизация аудио-ресурсов

**Наблюдение:** Проект содержит большое количество звуковых файлов в формате `.mp3`. Текущая реализация в `sound.service.ts` загружает их по требованию, что является правильным подходом и не блокирует начальную загрузку.

**Рекомендация:** Для дальнейшего улучшения можно рассмотреть:
- **Сжатие:** Проверить, можно ли сжать существующие `.mp3` файлы без значительной потери качества.
- **Современные форматы:** Перевести аудио в более эффективные форматы, такие как **Opus** (`.opus`) или **WebM** (`.webm`), которые обеспечивают лучшее сжатие при сопоставимом качестве. Это потребует проверки поддержки форматов в целевых браузерах.

## 4. Что работает хорошо

- **Загрузка Stockfish:** Шахматный движок Stockfish загружается через Web Worker и не является частью основного бандла. Это оптимальный подход, который предотвращает блокировку основного потока и пользовательского интерфейса во время сложных вычислений.
- **Копирование ассетов:** `vite-plugin-static-copy` используется для копирования файлов движка в папку `dist` без их включения в бандл, что также является правильной практикой.

## 5. Заключение

**Основной и самый важный шаг для оптимизации — это повсеместное внедрение динамических импортов для маршрутов в `src/router/index.ts`.** Это действие окажет наибольшее положительное влияние на производительность, решив как проблему большого бандла, так и проблему ненужной загрузки тяжелых зависимостей.
